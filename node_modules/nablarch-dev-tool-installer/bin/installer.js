'use strict';
require('sugar');

var fs      = require('fs')
  , path    = require('path')
  , http    = require('http')
  , crypto  = require('crypto')
  , shell   = require('shelljs')
  , Promise = global.Promise || require('es6-promise').Promise;

//定数定義
var PROJECT_ROOT    = process.env.PROJECT_ROOT
  , UI_PLUGINS_DIRS = process.env.UI_PLUGINS_DIRS
                    ? process.env.UI_PLUGINS_DIRS.split(',') : ['ui_plugins']
  , CACHE_DIR       = UI_PLUGINS_DIRS.map(function(pluginsDir) {
                        return path.join(PROJECT_ROOT, pluginsDir, '.npm');
                      })
  , REGISTRY_URL    = 'http://127.0.0.1:3000/'
  , PLUGIN_DIR      = '../node_modules'
  , PJ_PLUGIN_DIR   = UI_PLUGINS_DIRS.map(function(pluginsDir) {
                        return path.join(PROJECT_ROOT, pluginsDir, 'node_modules');
                      });

var LAST_PACKAGE = UI_PLUGINS_DIRS.map(function(pluginsDir) {
                     return path.resolve(path.join(PROJECT_ROOT, pluginsDir, 'lastInstallPackage.json'));
                   })
  , CURR_PACKAGE = UI_PLUGINS_DIRS.map(function(pluginsDir) {
                     return path.resolve(path.join(PROJECT_ROOT, pluginsDir, 'package.json'));
                   });

// キャッシュ追加処理の多重度(上げすぎるとハングする)
//var CACHE_ADD_MULTIPLICITY = 1; // 逐次実行
//var CACHE_ADD_MULTIPLICITY = 5;
var CACHE_ADD_MULTIPLICITY = 10;
//var CACHE_ADD_MULTIPLICITY = 20;
//var CACHE_ADD_MULTIPLICITY = 0; // 全部同時

var registryServer = null;

var nablarchDevelopMode = false;
var cleanMode = false;
if (process.argv.length > 2) {
  if (process.argv[2] === 'nablarchDevelopMode') {
    nablarchDevelopMode = true;
  } else if (process.argv[2] === 'clean') {
    cleanMode = true;
  }
}

// --- script main --- //
function main() {
  var currPromise = Promise.resolve([0]);
  for(var i = 0; i < UI_PLUGINS_DIRS.length; i++) {
    var uiPluginsDir = path.join(PROJECT_ROOT, UI_PLUGINS_DIRS[i]);
    if (fs.existsSync(uiPluginsDir)) {
      console.log('target dir:', uiPluginsDir);
    } else {
      console.log(uiPluginsDir, 'is not found.');
      continue;
    }
    
    if (nablarchDevelopMode) {
      // 開発モード
      currPromise = currPromise
        .then(createPluginLink);
    } else if (cleanMode) {
      // クリーンモード
      currPromise = currPromise
        .then(cleanup)
        .then(runAllNpmUninstall);
    } else {
      // 通常モード
      currPromise = currPromise
        .then(cleanup)
        .then(updatePluginCache)
        .then(startLocalRegistry)
        .then(runRejectedNpmUninstall)
        .then(runNpmInstall)
        .then(stopLocalRegistry);
    }
    currPromise = currPromise.then(countUpIndex);
//    currPromise = currPromise.catch(function(e) {
//      console.log(e);
//    });
  }
}

// --- subroutines --- //
/**
 * 前回のPromise値よりインデックスを取得する
 */
function currentIndexFromLastResult(lastPromiseResult) {
  return lastPromiseResult[0];
}

/**
 * インデックス情報を付加したPromise値を作成する
 */
function createResult(lastResult, currResult) {
  var idx = currentIndexFromLastResult(lastResult);
  return Promise.all(Array.create(
      Promise.resolve(idx), currResult
  ).flatten());
}

/**
 * 前回のPromise値のインデックスをインクリメントして設定する
 */
function countUpIndex(lastResult) {
  var idx = currentIndexFromLastResult(lastResult);
  return Promise.resolve([idx + 1]);
}

/**
 * 現在処理対象のキャッシュディレクトリを取得する
 */
function getCacheDir(lastPromiseResult) {
  return CACHE_DIR[currentIndexFromLastResult(lastPromiseResult)];
}

/**
 * 現在処理対象のプラグインディレクトリを取得する
 */
function getPluginsDir(lastPromiseResult) {
  return UI_PLUGINS_DIRS[currentIndexFromLastResult(lastPromiseResult)];
}

/**
 * 現在処理対象の前回インストールパッケージファイルを取得する
 */
function getLastPackageFile(lastPromiseResult) {
  return LAST_PACKAGE[currentIndexFromLastResult(lastPromiseResult)];
}

/**
 * 現在処理対象の今回インストールパッケージファイルを取得する
 */
function getCurrPackageFile(lastPromiseResult) {
  return CURR_PACKAGE[currentIndexFromLastResult(lastPromiseResult)];
}

/**
 * 現在処理対象のプロジェクトプラグインディレクトリを取得する
 */
function getPjPluginDir(lastPromiseResult) {
  return PJ_PLUGIN_DIR[currentIndexFromLastResult(lastPromiseResult)];
}

/**
 * テスト開発時に使用するシンボリックリンクを作成する
 */
function createPluginLink(lastResult) {
  var pjPluginDir = getPjPluginDir(lastResult);
  
  console.log('createPluginLink:', pjPluginDir);
  
  pjPluginDir = path.resolve(pjPluginDir);
  if(fs.existsSync(pjPluginDir)
     && fs.lstatSync(pjPluginDir).isSymbolicLink()) {
    fs.unlinkSync(pjPluginDir);
  };
  
  fs.symlinkSync(path.resolve(PLUGIN_DIR), pjPluginDir, 'junction');
  
  return createResult(lastResult, Promise.resolve(0));
}

/**
 * プロジェクトディレクトリのキャッシュを更新する
 */
function updatePluginCache(lastResult) {
  console.log('updatePluginCache:', getCacheDir(lastResult), CACHE_ADD_MULTIPLICITY);
  
  var currResult;
  if (CACHE_ADD_MULTIPLICITY === 0) {
    // 多重度0の場合は全て並列実行
    currResult = Promise.all(fs.readdirSync(PLUGIN_DIR).map(addPluginToCache));
    
  } else {
    // 多重度に合わせてリストを分割し、個別に並列実行
    var currPromise = Promise.resolve([0]);
    var fileList = fs.readdirSync(PLUGIN_DIR).filter(/^[^\.]/);
    var groupList = fileList.inGroups(fileList.length / CACHE_ADD_MULTIPLICITY);
    for(var i = 0; i < groupList.length; i++) {
      currPromise = currPromise.then(function(lastResult) {
        var idx = currentIndexFromLastResult(lastResult);
        return Promise.all(Array.create(
            Promise.resolve(idx + 1),
            groupList[idx].map(addPluginToCache)
        ).flatten());
      });
    }
    currResult = currPromise;
  }

  return createResult(lastResult, currResult);
  
  /**
   * プロジェクトディレクトリに個々のキャッシュを追加する
   */
  function addPluginToCache(pluginRoot) {
    if (pluginRoot.startsWith('.')) {
      return;
    }
    pluginRoot = path.join(PLUGIN_DIR, pluginRoot);
    return new Promise(function(resolve, reject) {
      shell.exec('npm cache add ' +  pluginRoot +  ' --cache ' +  getCacheDir(lastResult), function(code) {
        shell.echo('setup plugin: ' + pluginRoot);
        (code === 0) ? resolve()
                     : reject(new Error("Can't add the cache for the module at:" + pluginRoot));
      });
    });
  }
}

/**
 * プロジェクトディレクトリのキャッシュをクリアする
 */
function cleanup(lastResult) {
  console.log('cleanup:', getCacheDir(lastResult));
  
  var currResult = new Promise(function(resolve, reject) {
    var code = shell.exec('npm cache clean --cache ' + getCacheDir(lastResult)).code;
    (code === 0) ? resolve()
                 : reject();
  });
  
  return createResult(lastResult, currResult);
}

/**
 * プロジェクトディレクトリにインストールされているすべてのパッケージをアンインストールする
 */
function runAllNpmUninstall(lastResult) {
  var currPackageFile = getCurrPackageFile(lastResult);
  var lastPackageFile = getLastPackageFile(lastResult);
  
  console.log('runAllNpmUninstall:', currPackageFile, lastPackageFile);
  
  var currResult =  new Promise(function(resolve) {
    if (fs.existsSync(currPackageFile)) {
      var currPackage = require(currPackageFile)
        , packageDeps = Object.merge(currPackage.dependencies, currPackage.devDependencies);
      
      if (fs.existsSync(lastPackageFile)) {
        var lastPackage = require(lastPackageFile)
          , lastPackageDeps = Object.merge(lastPackage.dependencies, lastPackage.devDependencies);
        Object.merge(packageDeps, lastPackageDeps);
      }
      shell.pushd(path.join(PROJECT_ROOT, getPluginsDir(lastResult)));
      Object.extended(packageDeps).keys(function(packageName) {
        shell.echo('uninstall plugin: ' + packageName);
        shell.exec('npm uninstall ' + packageName);
      });
      shell.popd();
    }
    resolve();
  });
  
  return createResult(lastResult, currResult);
}

/**
 * 前回プロジェクトディレクトリにインストールされ、今回インストール対象外となったパッケージをアンインストールする
 */
function runRejectedNpmUninstall(lastResult) {
  var currPackageFile = getCurrPackageFile(lastResult);
  var lastPackageFile = getLastPackageFile(lastResult);
  
  console.log('runRejectedNpmUninstall:', currPackageFile, lastPackageFile);
  
  var currResult = new Promise(function(resolve) {
    if (fs.existsSync(lastPackageFile) && fs.existsSync(currPackageFile)) {
      var lastPackage = require(lastPackageFile)
        , currPackage = require(currPackageFile)
        , lastPackageDeps = Object.merge(lastPackage.dependencies, lastPackage.devDependencies)
        , currPackageDeps = Object.merge(currPackage.dependencies, currPackage.devDependencies)
        , removePackageDeps = Object.reject(lastPackageDeps, currPackageDeps);
      
      shell.pushd(path.join(PROJECT_ROOT, getPluginsDir(lastResult)));
      Object.extended(removePackageDeps).keys(function(packageName) {
        shell.echo('uninstall plugin: ' + packageName);
        shell.exec('npm uninstall ' + packageName);
      });
      shell.popd();
    }
    resolve();
  });
  
  return createResult(lastResult, currResult);
}

/**
 * プロジェクトディレクトリにpackage.jsonで指定されているパッケージをインストールする
 */
function runNpmInstall(lastResult) {
  console.log('runNpmInstall:', getPluginsDir(lastResult));
  
  var currPackageFile = getCurrPackageFile(lastResult);
  var lastPackageFile = getLastPackageFile(lastResult);
  
  var currResult = new Promise(function(resolve) {
    process.env.http_proxy = '';
    process.env.HTTP_PROXY = '';
    shell.pushd(path.join(PROJECT_ROOT, getPluginsDir(lastResult)));
    shell.exec(
      'npm install --registry ' + REGISTRY_URL + ' --cache .npm --no-optional'
    , function() {
        shell.cp('-f', currPackageFile, lastPackageFile);
        resolve();
      }
    );
    shell.popd();
  });
  
  return createResult(lastResult, currResult);
}

/**
 * ローカルレジストリサーバを停止する
 */
function stopLocalRegistry(lastResult) {
  console.log('stopLocalRegistry:', getCacheDir(lastResult));
  
  var currResult = new Promise(function(resolve, reject) {
    shell.echo('halting local repository ...');
    if (!registryServer) {
      resolve();
    }
    registryServer
    .on('close', function(){
      shell.echo('... local repository shutdown.');
      resolve();
    })
    .close();
  });
  
  return createResult(lastResult, currResult);
}

/**
 * ローカルレジストリサーバを起動する
 */
function startLocalRegistry(lastResult) {
  var cacheDir = getCacheDir(lastResult);
  console.log('startLocalRegistry:', cacheDir);
  
  var currResult = new Promise(function(resolve, reject) {
    shell.echo('starting local repository ...');
    registryServer = http.createServer()
    .on('request', function(req, res) {
      return (req.url.indexOf('.tgz') === -1)
           ? responsePackageJson(req, res, cacheDir)
           : responsePackageArchive(req, res, cacheDir);
    })
    .on('listening', function() {
      shell.echo('... local repository launched');
      resolve();
    })
    .listen(3000);
  });
  
  return createResult(lastResult, currResult);

  // --- subroutine --- //
  /**
   * package.jsonを返却する。
   */
  function responsePackageJson(req, res, cacheDir) {
    
    var body = getPackageJsonByUrlVersion(req, cacheDir);
    if (!body) {
      body = getPackageJsonAllVersion(req, cacheDir);
    }

    res.writeHead(200, {"Content-Type" : "text/plain", "Content-Length": body.length});
    res.write(body);
    res.end();
  }

  /**
   * urlで指定されたバージョンのpackage.jsonを取得する
   */
  function getPackageJsonByUrlVersion(req, cacheDir) {
    var pattern     = /.*\/([^\/]+)\/(\d+\.\d+\.\d+)?$/
      , m           = pattern.exec(req.url)
      , packageName = m && m[1]
      , version     = m && m[2];
    
    return m && new PackageInfo(packageName, version, cacheDir).toString();
  }
  
  /**
   * キャッシュ内全バージョンのpackage.jsonを取得する
   * (npm1.4.8以上でpackage.json取得リクエストの仕様が変わった)
   */
  function getPackageJsonAllVersion(req, cacheDir) {
    var pattern       = /.*\/([^\/]+)$/
      , m           = pattern.exec(req.url)
      , packageName = m && m[1];
    
    var versions = {};
    fs.readdirSync(path.join(cacheDir, packageName))
    .filter(function(n) {
      return n.match(/\d+\.\d+\.\d+/);
    })
    .each(function(version) {
      versions[version] = JSON.parse(new PackageInfo(packageName, version, cacheDir).toString());
    });
    
    return JSON.stringify({"versions":versions});
  }
  
  /**
   * パッケージアーカイブを返却する。
   */
  function responsePackageArchive(req, res, cacheDir) {
    var pattern     = /.*\/([^\/]+)\/-\/[^\/]+-(\d+\.\d+\.\d+)\/package\.tgz$/
      , m           = pattern.exec(req.url)
      , packageName = m && m[1]
      , version     = m && m[2]
      , archive     = new PackageInfo(packageName, version, cacheDir).getArchive();

    res.writeHead(200);
    res.write(archive);
    res.end();
  }
}

/**
 * パッケージ情報クラス
 */
PackageInfo.prototype = {
  toString   : PackageInfo_serialize
, getArchive : PackageInfo_getArchive
, calcDigest : PackageInfo_calcDigest
};

function PackageInfo(name, version, cacheDir) {
  this.constructor = PackageInfo;
  this.name = name;
  this.version = version;
  this._id = name;
  this._cacheDir = cacheDir;
}

function PackageInfo_serialize() {
  var versionInfo = {
    name : this.name
  , _id  : this.name
  , version: this.version
  , dist: {
      tarball : REGISTRY_URL + this.name + '/-/' + this.name + '-' + this.version + '/package.tgz'
    , shasum  : this.calcDigest()
    }
  };
  return JSON.stringify(versionInfo);
}

function PackageInfo_getArchive() {
  var archivePath = path.join(this._cacheDir, this.name, this.version, 'package.tgz');
  return fs.readFileSync(archivePath);
}

function PackageInfo_calcDigest() {
  var sum = crypto.createHash('sha1')
    , archive = this.getArchive();
  sum.update(archive);
  return sum.digest('hex');
}

main();

